
; PCW 1.15 lower jumpblock in bank 0
; Note: such small values definitely get picked up
; as literal constants, sigh.
;
JB_jump_bank2_env: equ 0x0
JB_jump_bc_addr: equ 0x03
JB_jump_de_addr: equ 0x05
JB_jump_hl_addr: equ 0x07
JB_jump_screen_env: equ 0x08
JB_jump_ix_addr: equ 0x0b
JB_jump_iy_addr: equ 0x0d
JB_jump_bank_env_ptr: equ 0x20
JB_jump_bank_env: equ 0x28
JB_jump_bank_env_hl: equ 0x28
JB_jump_kernel_panic: equ 0x030
JB_str_ascii_BREAK: equ 0x33
JB_rst_38_intr: equ 0x38
JB_str_ascii_PATCH: equ 0x3b
JB_hw_bitflags: equ 0x0040
JB_drive_B_present: equ 0x0042
JB_cfg_memory_bank_0000: equ 0x60
JB_cfg_memory_bank_4000: equ 0x61
JB_cfg_memory_bank_8000: equ 0x62
JB_cfg_memory_bank_c000: equ 0x63
JB_cnt_flyback: equ 0x64
JB_max_flyback: equ 0x65
JB_NMI_handler: equ 0x66

; 7a-7b : TBD - looks like memory bank config
; 7c-7d : TBD - for the NMI handler?
JB_num_banks: equ 0x7f

; PCW 1.15 XBIOS

dd_init: equ 0x80
dd_setup: equ 0x83
dd_read_sector: equ 0x0086
dd_write_sector: equ 0x0089
dd_check_sector: equ 0x008c
dd_format: equ 0x008f
dd_login: equ 0x0092
dd_sel_format: equ 0x0095
dd_drive_status: equ 0x0098
dd_read_id: equ 0x009b
dd_l_dpb: equ 0x009e
dd_l_xdpb: equ 0x00a1
dd_l_on_motor: equ 0x00a4
dd_l_t_off_motor: equ 0x00a7
dd_l_off_motor: equ 0x00aa
dd_l_read: equ 0x00ad
dd_l_write: equ 0x00b0
dd_l_seek: equ 0x00b3
cd_sa_init: equ 0x00b6
cd_sa_baud: equ 0x00b9
ca_sa_params: equ 0x00bc
te_ask: equ 0x00bf
te_reset: equ 0x00c2
te_stl_ask: equ 0x00c5
te_stl_on_off: equ 0x00c8
te_set_ink: equ 0x00cb
te_set_border: equ 0x00ce
te_set_speed: equ 0x00d1
km_set_expand: equ 0x00d4
km_set_key: equ 0x00d7
km_kt_get: equ 0x00da
km_kt_put: equ 0x00dd
km_set_speed: equ 0x00e0
cd_version: equ 0x00e3
cd_info: equ 0x00e6
scr_run_routine: equ 0x00e9
find_fid: equ 0x00ec

; extra calls for 1.15 and later
cd_sa_intstatus: equ 0x00ef
cd_coldboot: equ 0x00f2
svc_d_changed: equ 0x00f5
dd_calldriver: equ 0x00f8
msg_retrymsg: equ 0x00fb
msg_insert: equ 0x00fe
msg_sysmsg: equ 0x0101
kl_movemem: equ 0x0104

; xbios jumpblock memory variables
XBIOS_ca_sa_var_uart_present: equ 0x1131

; internal labels - for disassembly

;
; Announce the hardware configuration.
;
; This reads the current system configuration from low
; memory and prints the hardware configuration to the
; screen
;
; Assume all registers are corrupted.
;
XBIOS_jp_announce: equ 0x01a2

;
; Not JUST NMI init.
;
; This routine:
; * disables floppy interrupts
; * sets up the NMI handler
; * configures 0x7a -> 0x7f as a jump block
;   jumping to 0x5673 with a specific memory config
;   (0x83 and 0x81, I think that's for bank2 + bank1)
; * does some other table config at various addresses
;   (0x56e2 / 0x83 / 0x81; need to see where that
;   is programmed in!)
; * and does an LDIR to copy some data after some hijinx.
;
; I /think/ this is doing a bunch of jump table setup.
; However, I need to go finish figuring out what the
; other subroutines are doing to fully understand how
; things are being setup.
;
; Interesting addresses:
;
; 0x007a -> 0x007f
; 0x1121 -> 0x1122
; 0x1123 -> 0x1124
; 0x1125 -> 0x1126
; 0x1127 -> 0x1128
;
; Subroutines to figure out (that are loaded into
; jump tables, not CALLed directly)
;
; 0x5673 (xbios-4, floppy related?)
; 0x56e2 (xbios-4, floppy related?)
;
;
XBIOS_jp_init_jumptables: equ 0x0593

;
; TBD - figure out what this does
;
XBIOS_dd_unknown_1: equ 0x5673

;
; TBD - figure out what this does
;
XBIOS_dd_unknown_2: equ 0x56e2

;
; This looks like it tries to allocate some memory
; from the jumpblock scratch space.
;
; It does some simple bounds checking to ensure that
; allocations don't exceed the scratch space size.
;
; * Disables interrupts
; * Loads DE with what's at XBIOS_scratch_start_addr
; * adds HL to it, and stores it back at XBIOS_scratch_start_addr
; * BC = 0xEF8A (FFFF - EF8A = 0x1075, so that's how big the scratch
;   space is?)
; * HL = HL + BC
; * DE <-> HL
; Enable interrupts
; Return if NC (ie, I think if it managed to do it?)
; Else, RST 30 (kernel panic)
;
; Saves BC/DE.
;
; Returns the allocated address in HL.
;
; TODO: actually make EF8A a constant based on how much space?
; (ie, it /should/ be the space between two symbols...)
;
XBIOS_jb_alloc_scratch: equ 0x0baa

;
; These 0x11 bytes make up the original NMI
; routine which is copied into 0x0066.
;
XBIOS_nmi_routine_orig: equ 0x074d

;
; Perform initial hardware detection and setup.
;
; Configure the initial memory banks in 0x60/0x62,
; detect the 50/60Hz monitor config.
;
; Then, this blanks from XBIOS_jb_hw_setup for
; 0x02fa bytes (0x07db -> 0x1074).  I wonder if
; that is used as system state after this code
; is run.
;
XBIOS_jb_hw_setup: equ 0x0d7b

XBIOS_ldir_ret: equ 0x0d6c

;
; Configure bank1 + bank 2 and jump to address.
;
; HL points to a table that is arranged as
; follows:
;
; 2 byte jump address
; 1 byte memory bank configuration for bank 1
; 1 byte memory bank configuration for bank 2
;
; This routine configures bank 1 + bank 2,
; updates the memory bank state in low memory and then
; jumps to the provided jump address.
;
XBIOS_jb_bank1_2_far_jump: equ 0x0c25

;
; Store DE and the current bank configuration for
; bank 1 + 2 in the given table at HL.
;
XBIOS_jb_store_de_bank1_2_for_far_jump: equ 0x0c39

;
; Update HL' with the memory config based on
; the top two bits of H.
; 00 - HL' <= bank 0,1 config
; 01 - HL' <= bank 1,2 config
; 10 - HL' <= bank 2,3 config
; 11 - HL' <= bank 3 config, frame flyback counter
;
; This doesn't corrupt any registers.
;
XBIOS_jb_update_exhl: equ 0x0c46

;
; Set the 0x4000 bank to the given value in A.
;
; The old bank is returned in A.
;
XBIOS_jb_set_bank_4000: equ 0x0c68

;
; Set the 0x8000 bank to the given value in A.
;
; The old bank is returned in A.
;
XBIOS_jb_set_bank_8000: equ 0x0c74

;
; Call the given function on the stack with an alternate
; bank configuration for 0x4000 and 0x8000.
;
; This routine pops the address from the stack;
; loads 0x4000 bank from 0x1129, loads 0x8000 bank
; from 0x112a, then calls that routine.
; It then restores those two banks and returns.
;
XBIOS_jb_bank_1_2_config_and_jump: equ 0x0608

;
; Probe the RAM banks to see which are installed.
; This starts at RAM bank 0.
; Returns the number of banks in A.
; Assume all registers are trashed.
;
XBIOS_jb_probe_ram_bank: equ 0x0dc3

;
; Disconnect the FDD from NMI, and return from NMI.
;
XBIOS_fdd_nmi_disconnect_and_retn: equ 0x07cb

XBIOS_dd_init: equ 0x5410
XBIOS_dd_setup: equ 0x546d
XBIOS_dd_read_sector: equ 0x5111
XBIOS_dd_write_sector: equ 0x513e
XBIOS_dd_check_sector: equ 0x5149
XBIOS_dd_format: equ 0x5157
XBIOS_dd_login: equ 0x519d
XBIOS_dd_sel_format: equ 0x51f6
XBIOS_dd_drive_status: equ 0x53de
XBIOS_dd_read_id: equ 0x5125
XBIOS_dd_l_dpb: equ 0x524a
XBIOS_dd_l_xdpb: equ 0x5208
XBIOS_dd_l_on_motor: equ 0x56be
XBIOS_dd_l_t_off_motor: equ 0x56d6
XBIOS_dd_l_off_motor: equ 0x56ea
XBIOS_dd_l_read: equ 0x5617
XBIOS_dd_l_write: equ 0x5620
XBIOS_dd_l_seek: equ 0x550e

XBIOS_ca_sa_init: equ 0x3ebd
XBIOS_ca_sa_baud: equ 0x3e7e
XBIOS_ca_sa_params: equ 0x3f4e

XBIOS_te_ask: equ 0x4af3
XBIOS_te_reset: equ 0x492b
XBIOS_te_stl_ask: equ 0x4f57
XBIOS_te_stl_on_off: equ 0x4f6c
XBIOS_te_set_ink: equ 0x4d3a
XBIOS_te_set_border: equ 0x4d45
XBIOS_te_set_speed: equ 0x4d48

XBIOS_km_set_expand: equ 0x3d70
XBIOS_km_set_key: equ 0x3d6d
XBIOS_km_kt_get: equ 0x3d76
XBIOS_km_kt_put: equ 0x3d79
XBIOS_km_set_speed: equ 0x3d73

XBIOS_cd_version: equ 0x0197
XBIOS_cd_info: equ 0x017b

XBIOS_find_fid: equ 0x3dcb
XBIOS_ca_sa_intstatus: equ 0x40bd
XBIOS_cd_coldboot: equ 0x0107
XBIOS_svc_d_changed: equ 0x3df0
XBIOS_dd_calldriver: equ 0x3e0a
XBIOS_msg_retrymsg: equ 0x3d1d
XBIOS_msg_insert: equ 0x3d44
XBIOS_msg_sysmsg: equ 0x4de8
XBIOS_kl_movemem: equ 0x0c80


; xbios-4

; functions

XBIOS_internal_km_set_key: equ 0x447e
XBIOS_internal_km_set_expand: equ 0x41ae
XBIOS_internal_km_set_speed: equ 0x447a
XBIOS_internal_km_kt_get: equ 0x42e5

; Fetch the drive capability flags for Drive A or B.
;
; call: C=0 for drive A, C=1 for drive B
; ret: drive HW flags in bits 0..3, 5 of A.
;
XBIOS_internal_drive_get_capabilities: equ 0x5369

;
; Fetch the drive information table for the
; given drive.
; It only supports C=0..3 as it masks
; it with 0x3 first before doing the table
; lookup math.
;
; Note: it uses the table at 0x5847.
;
; call: C=0 .. 3 for drives A..D
; return: drive information address in HL.
;
XBIOS_internal_drive_get_info: equ 0x54fe

; sys msg related funcs to figure out
; XBIOS_msg_sysmsg
; 4e63
; 45d3
; 4f32
; 4e11 - checks the str for ff, exits when hit
; 4f40 - write str until ff, no expansion?

; 4e45: is this loading some offset value and adding it to hl,
; then doing some expansion?

;
; Write the space character via XBIOS_write_char.
;
; Corrupts: A.
XBIOS_write_space: equ 0x4f30

;
; Write the given character in A.
;
; It uses whatever function is in 0x5704 to do the work;
; so callers need to initialise that address first with
; a routine to actually output the character.
;
; Saves: BC, DE, HL.
; Corrupts: AF.
;
XBIOS_write_char: equ 0x4f32

;
; Write the given string pointed to at HL to the current
; output device via XBIOS_write_char.
;
; The string isn't expanded with tokens, and is terminated.
; with 0xff.
; Corrupts: HL at least, likely AF, BC, DE too.
;
XBIOS_write_str_no_expansion: equ 0x4f40

; XBIOS_msg_sysmsg:
; stores 0xba09 -> 0x5704, and then uses this to write to
; my guess is it's using 0x5704 as the "output function",
; so callers to XBIOS_write_* above have to set said
; output function first in 0x5704 and then it'll write
; to that.

; 0x0242 - 'drive not ready' string

; 0x4d90 -> 0x4de7 - .. what's this? it doesn't look
; like valid code?

;
; Initialise the UART at 0xe3.
;
; This writes a set of configuration bytes to the UART.

XBIOS_internal_cps8256_uart_init: equ 0x3d7c

;
; Check if the standalone printer port is ready.
;
; This returns Z=true if the port is ready, Z=false otherwise.
; Corrupts: A.
;
XBIOS_internal_standalone_cen_is_printer_ready: equ 0x3dc4

;
; Check if the CPS8256 printer port is ready.
;
; This returns C=true flag if the port is ready.
; Corrupts: A.
;
XBIOS_internal_cps8256_cen_is_printer_ready: equ 0x3da3

;
; Write the given byte to the standalone centronics port.
;
; This will wait until the port is ready, and then
; send the byte in A.
;
; Corrupts: C.
;
XBIOS_internal_standalone_cen_wait_write_byte: equ 0x3db5

;
; Write the given config byte to the standalone centronics printer port.
; (XXX TODO?)
;
; This writes the byte in A to the standalone centronics
; printer port config port (0x84), rather than the data port
; (0x85.)
;
XBIOS_internal_standalone_cen_config: equ 0x3dae

; 3d8c: looks like a UART init routine? See what it's
; calling and what HL is pointing to

; 3f2c: outputting h, l and h to an IO port, then
; reading from it, and AND'ing 0xf8.  See what's calling it,
; I wonder if it's a printer or UART. (eg 0x02, 0xa5, 0x02 sent
; to the register as called from around 3f12.

; look at XBIOS_cd_info as it probes the drives, reads the
; hw state flags, etc.  Annotate those.

; variables


; XBIOS_ca_sa_params state
XBIOS_internal_ca_sa_stopbits: equ 0x5875
XBIOS_internal_ca_sa_parity: equ 0x5874
XBIOS_internal_ca_sa_tx_data_bits: equ 0x5876
XBIOS_internal_ca_sa_rx_data_bits: equ 0x5877
; unknown
XBIOS_internal_ca_sa_reg_bc: equ 0x5870
; unknown
XBIOS_internal_ca_sa_reg_a: equ 0x5872


XBIOS_te_viewport_left: equ 0x5825
XBIOS_te_viewport_top: equ 0x5826
XBIOS_te_viewport_width: equ 0x5821
XBIOS_te_viewport_height: equ 0x5822
XBIOS_te_viewport_cursor_col: equ 0x5828
XBIOS_te_viewport_cursor_row: equ 0x5829


; unknown memory addresses (not yet in the disassembly,
; but referenced somewhere.)

; Note: 0x5703 is currently the /end/ of the disassembly
; of xbios-4.bin.  0x5704 (the first variable) starts
; immediately there.

; Used by XBIOS_write_char as a function pointer to
; call for each character being written.  Two bytes.
XBIOS_write_char_out_func: equ 0x5704

; Drive table - used by XBIOS_internal_drive_get_info ;
; not sure what the format is.
XBIOS_drive_table: equ 0x5847

; XXX TODO: do I have these two around the right way?
XBIOS_bank_1_2_jump_bc_bank_2: equ 0x1129
XBIOS_bank_1_2_jump_bc_bank_1: equ 0x112a

; This is initially setup with the start address of
; the scratch space available after XBIOS_jp_hw_setup
; does initial hardware setup.
XBIOS_scratch_start_addr: equ 0x111a
